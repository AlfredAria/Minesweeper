<!doctype html>
<!-- 
	Mine-swap game boilerplates.
	The user behavior grid update is not implemented yet.

	Author: Alfred Huang
	Date updated: 2021.9.4
-->
<html lang="en-US">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<body>
	<div id="board-container"></div>
</body>
<style>
	.rows {
		display: block;
		white-space: nowrap;
		height: 20px;
	}

	.grids {
		box-sizing: border-box;
		border: 1px solid black;
		width: 20px;
		height: 20px;
		display: inline-block;
		white-space: nowrap;
		text-align: center;
		text-overflow: hidden;
		overflow: hidden;		
	}

	.grids.red {
		background-color: red;
	}
</style>
<script>
	// --- Answers for this game ---
	// --- TODO: 
	//   Players can see the answer by debugging rightaway.
	//   Instead, generate a problem server side and only 
	//   compare answers when a player makes moves.
	// ---
	const ROWS = 20;  // Total rows of the game board.
	const COLS = 20;  // Total columns of the game board.
	const MINES = 20; // Total mines to put on the grids.

	const EMPTY = 0;  // A grid that has no mine.
	const MINE = 1; // A grid that has a mine.

	const matrix = []; // The game matrix.

	// --- Board states from user move ---
	const results = []; // The play state matrix.
	const gridStates = {
		UNREVEALED: 0, // A grid has not been revealed by the user.
		NUMBER: 1,  // A grid is revealed and indicates that some nearby grid has mines.
					// The grid is displayed as the number that indicates how many mines
					// are nearby.
		BLANK: 2,  // A grid is revealed and indicates that there is no mine near this grid.
		CROSS: 3,  // A grid is revealed and is a mine, which is the result of a player
				   // lossing a game.
		LOWER_CROSS: 4, // A grid is revealed when the game reveals all answers to the player.
	};

	// Shuffling
	// Reference: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
	function shuffle(array) {
	  var currentIndex = array.length,  randomIndex;

	  // While there remain elements to shuffle...
	  while (currentIndex != 0) {

	    // Pick a remaining element...
	    randomIndex = Math.floor(Math.random() * currentIndex);
	    currentIndex--;

	    // And swap it with the current element.
	    [array[currentIndex], array[randomIndex]] = [
	      array[randomIndex], array[currentIndex]];
	  }

	  return array;
	}

	function initGameMatrix() {
		// Init an empty answer matrix.
		for (let y = 0; y < ROWS; y ++) {
			matrix[y] = [];
			for (let x = 0; x < COLS; x ++) {
				matrix[y][x] = EMPTY;
			}
		}
		// Init an index array, shuffle it and use
		// first MINES entries as random mine blocks.
		let array = []
		for (let y = 0; y < ROWS; y ++) {
			for (let x = 0; x < COLS; x ++) {
				array.push(y * COLS + x);
			}
		}
		array = shuffle(array);
		for (let count = 0; count < MINES; count ++) {
			const row = Math.floor(array[count] / COLS);
			const col = array[count] % COLS;
			matrix[row][col] = MINE;
		}

		// Init an unrevealed state matrix.
		for (let y = 0; y < ROWS; y ++) {
			results[y] = [];
			for (let x = 0; x < COLS; x ++) {
				results[y][x] = {
					state: gridStates.UNREVEALED
				};
			}
		}
	}

	// Recursively set grids to be revealed, if they have not.
	const DELTA = [[-1, 0],[1, 0],[0, -1],[0, 1],[-1, -1],[1, -1],[-1, 1],[1, 1]];
	function revealNonMineGrids(element, y, x) {

		let count = 0;

		// Count number of mines near the grid.
		for (const dydx of DELTA) {
			const dy = dydx[0];
			const dx = dydx[1];
			const y1 = dy + y;
			const x1 = dx + x;
			if (y1 < 0 || x1 < 0 || y1 >= ROWS || x1 >= COLS || matrix[y1][x1] !== MINE) {
				continue;
			}
			count++;
		}

		// Update UI to display a reveaded number or empty slot.
		element.innerHTML = count > 0 ? count : '.';
		results[y][x].state = count > 0 ? gridStates.NUMBER : gridStates.BLANK;

		// This will require user to keep trying to find grids with numbers,
		// instead of recursively revealing all of them.
		if (count > 0) {
			return;
		}

		// If this is an empty grid with no mines nearby,
		// search nearby grids until numbered grids are revealed.
		// Only 4 directions and not the diagnols should be searched
		// as a game rule.
		for (const dydx of DELTA.slice(0, 4)) {
			const dy = dydx[0];
			const dx = dydx[1];
			const y1 = dy + y;
			const x1 = dx + x;
			if (y1 < 0 || x1 < 0 || y1 >= ROWS || x1 >= COLS || results[y1][x1].state !== gridStates.UNREVEALED) {
				continue;
			}
			// Mine grids will not be revealed.
			if (matrix[y1][x1] === MINE) {
				continue;
			}
			// Select the unique grid in the matrix and modify its view.
			const nearbyElement = document.querySelector(`.grids[key=${'k' + (y1 * COLS + x1)}]`);
			revealNonMineGrids(nearbyElement, y1, x1);
		}

	}

	function reviewAllMines(clickedElement, rowClicked, colClicked) {
		results[rowClicked][colClicked].state = gridStates.CROSS;
		renderGrid(clickedElement, rowClicked, colClicked)
		clickedElement.className = clickedElement.className + ' red';
		for (let y = 0; y < ROWS; y ++) {
			for (let x = 0; x < COLS; x ++) {
				if (y === rowClicked && x === colClicked) {
					continue;
				}
				if (matrix[y][x] === MINE) {
					results[y][x].state = gridStates.LOWER_CROSS;
					const changedElement = document.querySelector(`.grids[key=${'k' + (y * COLS + x)}]`);
					renderGrid(changedElement, y, x);
				}
			}
		}
	}
	
	function handleClickOnGrid(element, rowNum, colNum) {

		if (results[rowNum][colNum].state !== gridStates.UNREVEALED) {
			// Do nothing if the grid already has the answer.
			return;
		}

		switch(matrix[rowNum][colNum]) {
			case MINE:
				reviewAllMines(element, rowNum, colNum);
				console.log(`Player clicked on grid ${rowNum},${colNum} which is a mine.`);
				// TODO: Explode.
				break;

			default:
			case EMPTY:
				console.log(`Player clicked on grid ${rowNum},${colNum} which is not a mine.`);
				revealNonMineGrids(element, rowNum, colNum);
				break;
		}
	}

	function renderGrid(element, row, col) {
		// Code to review answer at start of game play.
		// element.innerHTML = matrix[row][col] === MINE ? 'X' : '';

		let displayedText = element.innerHTML;
		switch(results[row][col].state) {
			case (gridStates.UNREVEALED):
				displayedText = ' ';
				break;
			case (gridStates.BLANK):
				displayedText = '.';
				break;
			case (gridStates.NUMBER):
				displayedText = element.innerHTML;
				break;
			case (gridStates.CROSS):
				displayedText = 'X';
				break;
			case (gridStates.LOWER_CROSS):
				displayedText = 'x';
				break;
		}
		element.innerHTML = displayedText;
	}

	function renderGame() {
		const board = document.createElement('div');
		board.className = "board";
		for (let r = 0; r < ROWS; r ++) {
			const row = document.createElement('div');
			row.className = "rows";
			for (let c = 0; c < COLS; c ++) {
				const grid = document.createElement('div');
				grid.className = "grids";
				grid.setAttribute('key', 'k' + (r * COLS + c));
				grid.setAttribute('r', r);
				grid.setAttribute('c', c);
				renderGrid(grid, r, c);
				row.appendChild(grid);
			}
			board.appendChild(row);
		}
		board.onclick = (evt) => {
			const gridTarget = evt.target;
			if (!gridTarget.getAttribute("key")) {
				// Not a click on one of the grids.
				return;
			}
			const rowNum = Number.parseInt(gridTarget.getAttribute('r'));
			const colNum = Number.parseInt(gridTarget.getAttribute('c'));
			handleClickOnGrid(gridTarget, rowNum, colNum);
		};
		document.getElementById('board-container').appendChild(board);
	}

	window.onload = (evt) => {
		initGameMatrix();
		renderGame();
	}
</script>
</html>