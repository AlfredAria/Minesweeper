<!doctype html>
<!-- 
	Mine-swap game boilerplates.
	The user behavior grid update is not implemented yet.

	Author: Alfred Huang
	Date updated: 2021.9.4
-->
<html lang="en-US">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<body>
	<div class="control-group">
		<button id="restart">Restart</button>
	</div>
	<div id="board-container"></div>
</body>
<style>
	.control-group {
		margin: 20px 0;
	}

	.rows {
		display: block;
		white-space: nowrap;
		height: 20px;
	}

	.grids {
		box-sizing: border-box;
		border: 1px solid black;
		width: 20px;
		height: 20px;
		display: inline-block;
		white-space: nowrap;
		text-align: center;
		text-overflow: hidden;
		overflow: hidden;		
	}

	.grids.red {
		background-color: red;
	}
</style>
<script>
	// --- Answers for this game ---
	// --- TODO: 
	//   Players can see the answer by debugging rightaway.
	//   Instead, generate a problem server side and only 
	//   compare answers when a player makes moves.
	// ---
	const ROWS = 20;  // Total rows of the game board.
	const COLS = 20;  // Total columns of the game board.
	const MINES = 20; // Total mines to put on the grids.

	const EMPTY = 0;  // A grid that has no mine.
	const MINE = 1; // A grid that has a mine.

	const matrix = []; // The game matrix.

	// --- Board states from user move ---
	const results = []; // The play state matrix.
	const gridStates = {
		UNREVEALED: 0, // A grid has not been revealed by the user.
		NUMBER: 1,  // A grid is revealed and indicates that some nearby grid has mines.
					// The grid is displayed as the number that indicates how many mines
					// are nearby.
		BLANK: 2,  // A grid is revealed and indicates that there is no mine near this grid.
		CROSS: 3,  // A grid is revealed and is a mine, which is the result of a player
				   // lossing a game.
		LOWER_CROSS: 4, // A grid is revealed when the game reveals all answers to the player.
	};

	let gameBoard;

	// Shuffling
	// Reference: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array
	function shuffle(array) {
	  var currentIndex = array.length,  randomIndex;

	  // While there remain elements to shuffle...
	  while (currentIndex != 0) {

	    // Pick a remaining element...
	    randomIndex = Math.floor(Math.random() * currentIndex);
	    currentIndex--;

	    // And swap it with the current element.
	    [array[currentIndex], array[randomIndex]] = [
	      array[randomIndex], array[currentIndex]];
	  }

	  return array;
	}

	function initGameMatrix() {
		// Init an empty answer matrix.
		for (let y = 0; y < ROWS; y ++) {
			matrix[y] = [];
			for (let x = 0; x < COLS; x ++) {
				matrix[y][x] = EMPTY;
			}
		}
		// Init an index array, shuffle it and use
		// first MINES entries as random mine blocks.
		let array = []
		for (let y = 0; y < ROWS; y ++) {
			for (let x = 0; x < COLS; x ++) {
				array.push(y * COLS + x);
			}
		}
		array = shuffle(array);
		for (let count = 0; count < MINES; count ++) {
			const row = Math.floor(array[count] / COLS);
			const col = array[count] % COLS;
			matrix[row][col] = MINE;
		}

		// Init an unrevealed state matrix.
		for (let y = 0; y < ROWS; y ++) {
			results[y] = [];
			for (let x = 0; x < COLS; x ++) {
				results[y][x] = {
					state: gridStates.UNREVEALED
				};
			}
		}
	}

	const uiHelpers = {
		createGridFor(r, c) {
			const grid = document.createElement('div');
			grid.className = "grids";
			grid.setAttribute('key', 'k' + (r * COLS + c));
			grid.setAttribute('r', r);
			grid.setAttribute('c', c);
			grid.innerHTML = '';
			return grid;
		},
		getClickedGridAttribute(element) {
			if (!element.getAttribute("key")) {
				// Not a click on one of the grids.
				return {rowNum: -1, colNum: -1};
			}
			const rowNum = Number.parseInt(element.getAttribute('r'));
			const colNum = Number.parseInt(element.getAttribute('c'));
			return {rowNum, colNum};
		},
		getGridElement(y, x) {
			return document.querySelector(`.grids[key=${'k' + (y * COLS + x)}]`);
		},
		setGridDisplayContent(y, x, content) {
			uiHelpers.getGridElement(y, x).innerHTML = content;
		},
		markRedGrid(y, x) {
			const grid = uiHelpers.getGridElement(y, x);
			grid.className = grid.className + ' red';
		}
	}

	// Recursively set grids to be revealed, if they have not.
	const DELTA = [[-1, 0],[1, 0],[0, -1],[0, 1],[-1, -1],[1, -1],[-1, 1],[1, 1]];
	function revealNonMineGrids(y, x) {
		let count = 0;

		// Count number of mines near the grid.
		for (const dydx of DELTA) {
			const dy = dydx[0];
			const dx = dydx[1];
			const y1 = dy + y;
			const x1 = dx + x;
			if (y1 < 0 || x1 < 0 || y1 >= ROWS || x1 >= COLS || matrix[y1][x1] !== MINE) {
				continue;
			}
			count++;
		}

		// Update UI to display a reveaded number or empty slot.
		results[y][x].state = count > 0 ? gridStates.NUMBER : gridStates.BLANK;
		uiHelpers.setGridDisplayContent(y, x, count ? count : '.');

		// This will require user to keep trying to find grids with numbers,
		// instead of recursively revealing all of them.
		if (count > 0) {
			return;
		}

		// If this is an empty grid with no mines nearby,
		// search nearby grids until numbered grids are revealed.
		// Only 4 directions and not the diagnols should be searched
		// as a game rule.
		for (const dydx of DELTA.slice(0, 4)) {
			const dy = dydx[0];
			const dx = dydx[1];
			const y1 = dy + y;
			const x1 = dx + x;
			if (y1 < 0 || x1 < 0 || y1 >= ROWS || x1 >= COLS || results[y1][x1].state !== gridStates.UNREVEALED) {
				continue;
			}
			// Mine grids will not be revealed.
			if (matrix[y1][x1] === MINE) {
				continue;
			}
			revealNonMineGrids(y1, x1);
		}

	}

	function reviewAllMines(rowClicked, colClicked) {
		results[rowClicked][colClicked].state = gridStates.CROSS;
		uiHelpers.setGridDisplayContent(rowClicked, colClicked, 'X');
		uiHelpers.markRedGrid(rowClicked, colClicked);

		for (let y = 0; y < ROWS; y ++) {
			for (let x = 0; x < COLS; x ++) {
				if (y === rowClicked && x === colClicked) {
					continue;
				}
				if (matrix[y][x] === MINE) {
					results[y][x].state = gridStates.LOWER_CROSS;
					uiHelpers.setGridDisplayContent(y, x, 'x');
				}
			}
		}
	}
	
	function handleClickOnGrid(rowNum, colNum) {
		if (results[rowNum][colNum].state !== gridStates.UNREVEALED) {
			// Do nothing if the grid already has the answer.
			return;
		}

		switch(matrix[rowNum][colNum]) {
			case MINE:
				reviewAllMines(rowNum, colNum);
				console.log(`Player clicked on grid ${rowNum},${colNum} which is a mine.`);
				gameBoard.disable();
				break;

			default:
			case EMPTY:
				console.log(`Player clicked on grid ${rowNum},${colNum} which is not a mine.`);
				revealNonMineGrids(rowNum, colNum);
				break;
		}
	}

	function renderGame() {
		gameBoard = new Board();
		board = gameBoard.element;
		board.className = "board";
		for (let r = 0; r < ROWS; r ++) {
			const row = document.createElement('div');
			row.className = "rows";
			for (let c = 0; c < COLS; c ++) {
				row.appendChild(uiHelpers.createGridFor(r, c));
			}
			board.appendChild(row);
		}
		document.getElementById('board-container').appendChild(board);
	}

	function gridIsClicked(evt) {
		const {rowNum, colNum} = uiHelpers.getClickedGridAttribute(evt.target);
		if (rowNum >= 0 && colNum >= 0) {
			handleClickOnGrid(rowNum, colNum);
		}
	}

	function Board() {
		this.element = document.createElement('div');
		this.element.className = "board";
		this.element.addEventListener('click', gridIsClicked);
	}

	Board.prototype.disable = function() {
		this.element.removeEventListener('click', gridIsClicked);
	}

	function destroyExistingGame() {
		const container = document.getElementById('board-container');
	    while (container.firstChild) {
	        container.removeChild(container.firstChild);
	    }
    }

	function restart() {
		destroyExistingGame();
		initGameMatrix();
		renderGame();
	}

	window.onload = restart;
	document.getElementById('restart').addEventListener('click', restart);
</script>
</html>